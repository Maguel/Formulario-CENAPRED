---
// src/components/CroquisInmueble.astro
// Componente para dibujar el croquis del inmueble con indicador de norte
// Incluye opciones para marcar tipos de planos existentes

interface Props {
  class?: string;
  readonly?: boolean;
}

const { class: className, readonly = false } = Astro.props;
---

<section class={`panel ${className ?? ""}`} data-readonly={readonly}>
  <header class="panel__header">
    <h2>CROQUIS DEL INMUEBLE</h2>

    <div class="plans" role="group" aria-label="Planos existentes">
      <span class="lbl">Existen planos:</span>
      <label class="chk chk--inline">
        <input
          type="checkbox"
          name="planos"
          value="arquitectonico"
          disabled={readonly}
        />
        <span>Arquitectónico</span>
      </label>
      <label class="chk chk--inline">
        <input
          type="checkbox"
          name="planos"
          value="estructural"
          disabled={readonly}
        />
        <span>Estructural</span>
      </label>
      <label class="chk chk--inline">
        <input
          type="checkbox"
          name="planos"
          value="ninguno"
          disabled={readonly}
        />
        <span>Ninguno</span>
      </label>
    </div>
  </header>

  <!-- Área de croquis -->
  <div class="sketch-wrap">
    <div class="north-indicator">
      <span class="note">(Marcar el Norte)</span>
      <div class="arrow" aria-label="Indicador de norte">
        <span class="shaft"></span>
        <span class="head"></span>
      </div>
      <span class="n">N</span>
    </div>

    <!-- Controles de dibujo -->
    {
      !readonly && (
        <div class="drawing-controls">
          <button
            id="undo-btn"
            class="control-btn"
            title="Deshacer"
            aria-label="Deshacer último trazo"
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M3 7v6h6" />
              <path d="M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13" />
            </svg>
            <span>Deshacer</span>
          </button>
          <button
            id="clear-btn"
            class="control-btn control-btn--danger"
            title="Borrar todo"
            aria-label="Borrar todo el dibujo"
          >
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polyline points="3 6 5 6 21 6" />
              <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" />
            </svg>
            <span>Borrar todo</span>
          </button>
        </div>
      )
    }

    <div
      class="sketch"
      aria-label="Área para dibujar el croquis"
      role="img"
      tabindex={readonly ? undefined : "0"}
    >
      <canvas id="sketch-canvas" class="sketch__canvas" aria-hidden="true"
      ></canvas>
    </div>
  </div>
</section>

<style>
  /* ===== Variables CSS ===== */
  :root {
    --color-primary: #00b7c7;
    --color-primary-dark: #0aa;
    --color-primary-light: #69cfd9;
    --color-grid-strong: #8ddbe3;
    --color-grid-weak: #cfeff3;
    --color-text: #111;
    --color-text-dark: #0f0f0f;
    --color-text-muted: #335e64;
    --color-bg: #fff;
    --color-danger: #dc3545;
    --color-danger-hover: #c82333;
    --color-drawing: #003d82; /* Azul oscuro para el pincel */
    --font-family: Arial, Helvetica, sans-serif;
    --font-size-base: 13.5px;
    --font-size-sm: 12px;
    --font-size-md: 14px;
    --font-size-lg: 15.5px;
    --border-width: 2px;
    --panel-width: min(1060px, 100vw);
    --spacing-xs: 0.15rem;
    --spacing-sm: 0.4rem;
    --spacing-md: 0.55rem;
    --spacing-lg: 0.9rem;
    --spacing-xl: 14px;
    --grid-size: 20px;
  }

  /* ===== Panel Container ===== */
  .panel {
    width: var(--panel-width);
    margin: var(--spacing-xl) auto;
    border: var(--border-width) solid var(--color-primary);
    background: var(--color-bg);
    font-family: var(--font-family);
    color: var(--color-text);
    font-size: var(--font-size-base);
    border-radius: 4px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  /* ===== Panel Header ===== */
  .panel__header {
    background: var(--color-primary);
    color: var(--color-bg);
    padding: var(--spacing-md) var(--spacing-lg);
    border-bottom: var(--border-width) solid var(--color-primary-dark);
    display: grid;
    grid-template-columns: 1fr auto;
    align-items: end;
    gap: 0.75rem;
  }

  .panel__header h2 {
    margin: 0;
    font-size: var(--font-size-lg);
    font-weight: 800;
    letter-spacing: 0.2px;
  }

  /* ===== Plans Selector ===== */
  .plans {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    flex-wrap: wrap;
  }

  .lbl {
    font-weight: 700;
  }

  /* ===== Checkbox Styles ===== */
  .chk {
    display: inline-flex;
    align-items: center;
    gap: var(--spacing-sm);
    cursor: pointer;
  }

  .chk input[type="checkbox"] {
    appearance: none;
    width: 14px;
    height: 14px;
    border: 1.8px solid var(--color-text-dark);
    background: var(--color-bg);
    display: inline-grid;
    place-items: center;
    cursor: pointer;
    transition: all 0.2s ease;
    flex-shrink: 0;
  }

  .chk input[type="checkbox"]:checked {
    background: var(--color-primary);
    box-shadow: inset 0 0 0 2px var(--color-bg);
  }

  .chk input[type="checkbox"]:focus-visible {
    outline: 2px solid var(--color-bg);
    outline-offset: 2px;
  }

  .chk input[type="checkbox"]:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .chk--inline {
    gap: 0.35rem;
  }

  /* ===== Drawing Controls ===== */
  .drawing-controls {
    position: absolute;
    top: 10px;
    left: 10px;
    display: flex;
    gap: 8px;
    z-index: 10;
  }

  .control-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 12px;
    background: var(--color-bg);
    border: 2px solid var(--color-primary);
    color: var(--color-primary-dark);
    border-radius: 4px;
    font-size: var(--font-size-sm);
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  }

  .control-btn:hover {
    background: var(--color-primary);
    color: var(--color-bg);
    transform: translateY(-1px);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  }

  .control-btn:active {
    transform: translateY(0);
  }

  .control-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  .control-btn:disabled:hover {
    background: var(--color-bg);
    color: var(--color-primary-dark);
  }

  .control-btn--danger {
    border-color: var(--color-danger);
    color: var(--color-danger);
  }

  .control-btn--danger:hover {
    background: var(--color-danger);
    color: var(--color-bg);
  }

  .control-btn svg {
    width: 16px;
    height: 16px;
  }

  .control-btn span {
    display: none;
  }

  @media (min-width: 480px) {
    .control-btn span {
      display: inline;
    }
  }

  /* ===== Sketch Area ===== */
  .sketch-wrap {
    position: relative;
    padding: 10px 10px 12px;
    border-top: var(--border-width) solid var(--color-primary);
  }

  /* ===== Grid Background Pattern ===== */
  .sketch {
    height: clamp(360px, 48vw, 520px);
    border: var(--border-width) solid var(--color-primary);
    background:
      /* Líneas gruesas cada 5 celdas */
      linear-gradient(var(--color-grid-strong) 2px, transparent 2px) top left /
        100% calc(var(--grid-size) * 5),
      linear-gradient(90deg, var(--color-grid-strong) 2px, transparent 2px) top
        left / calc(var(--grid-size) * 5) 100%,
      /* Grid fino */
        repeating-linear-gradient(
          var(--color-grid-weak) 0 1px,
          transparent 1px var(--grid-size)
        ),
      repeating-linear-gradient(
        90deg,
        var(--color-grid-weak) 0 1px,
        transparent 1px var(--grid-size)
      );
    background-repeat: repeat;
    box-shadow: inset 0 0 0 2px var(--color-primary-light);
    position: relative;
    overflow: hidden;
    cursor: crosshair;
  }

  .sketch:focus-visible {
    outline: 2px solid var(--color-primary);
    outline-offset: 2px;
  }

  [data-readonly="true"] .sketch {
    cursor: default;
  }

  /* ===== Canvas para dibujo ===== */
  .sketch__canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }

  /* ===== North Indicator ===== */
  .north-indicator {
    position: absolute;
    top: 10px;
    right: 14px;
    display: grid;
    justify-items: center;
    gap: var(--spacing-xs);
    color: var(--color-text-dark);
    z-index: 10;
  }

  .north-indicator .note {
    font-size: var(--font-size-sm);
    color: var(--color-text-muted);
  }

  .north-indicator .n {
    font-weight: 800;
    font-size: var(--font-size-md);
    margin-top: -2px;
  }

  /* ===== Arrow Design ===== */
  .arrow {
    position: relative;
    width: 0;
    height: 48px;
    display: grid;
    place-items: center;
  }

  .shaft {
    width: 2px;
    height: 46px;
    background: var(--color-text-dark);
    display: block;
  }

  .head {
    position: absolute;
    top: -2px;
    width: 0;
    height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-bottom: 10px solid var(--color-text-dark);
  }

  /* ===== Responsive Design ===== */
  @media (max-width: 760px) {
    .panel__header {
      grid-template-columns: 1fr;
    }

    .plans {
      justify-content: flex-start;
    }

    .north-indicator .note {
      font-size: 11.5px;
    }

    .drawing-controls {
      position: relative;
      top: 0;
      left: 0;
      margin-bottom: 8px;
      justify-content: center;
    }
  }

  @media (max-width: 420px) {
    .sketch {
      height: 320px;
    }

    .north-indicator {
      right: 10px;
    }

    .plans {
      gap: var(--spacing-md);
    }

    .chk {
      width: 100%;
    }

    .control-btn {
      padding: 8px;
    }

    .control-btn span {
      display: none;
    }
  }
</style>

<script>
  // Tipos para el manejo del canvas
  interface Point {
    x: number;
    y: number;
  }

  interface Stroke {
    points: Point[];
    color: string;
    lineWidth: number;
  }

  interface DrawingState {
    isDrawing: boolean;
    currentStroke: Point[];
    strokes: Stroke[];
    readonly: boolean;
  }

  class SketchCanvas {
    private canvas: HTMLCanvasElement | null;
    private ctx: CanvasRenderingContext2D | null;
    private container: HTMLElement | null;
    private state: DrawingState;
    private checkboxes: NodeListOf<HTMLInputElement>;
    private undoBtn: HTMLButtonElement | null;
    private clearBtn: HTMLButtonElement | null;
    private strokeColor: string = "#003d82"; // Azul oscuro
    private strokeWidth: number = 2.5;

    constructor() {
      this.canvas = document.getElementById(
        "sketch-canvas",
      ) as HTMLCanvasElement;
      this.container = this.canvas?.closest(".sketch") as HTMLElement;
      this.ctx = this.canvas?.getContext("2d") ?? null;
      this.checkboxes = document.querySelectorAll('input[name="planos"]');
      this.undoBtn = document.getElementById("undo-btn") as HTMLButtonElement;
      this.clearBtn = document.getElementById("clear-btn") as HTMLButtonElement;

      this.state = {
        isDrawing: false,
        currentStroke: [],
        strokes: [],
        readonly:
          this.container
            ?.closest("[data-readonly]")
            ?.getAttribute("data-readonly") === "true",
      };

      this.init();
    }

    private init(): void {
      if (!this.canvas || !this.ctx || !this.container) return;

      // Configurar el canvas
      this.setupCanvas();

      // Event listeners para los checkboxes
      this.setupCheckboxes();

      // Event listeners para el dibujo (si no es readonly)
      if (!this.state.readonly) {
        this.setupDrawingEvents();
        this.setupControlButtons();
      }

      // Manejar resize
      window.addEventListener("resize", this.handleResize.bind(this));
    }

    private setupCanvas(): void {
      if (!this.canvas || !this.container) return;

      const rect = this.container.getBoundingClientRect();
      this.canvas.width = rect.width;
      this.canvas.height = rect.height;

      // Configurar estilos del contexto con el nuevo color azul oscuro
      if (this.ctx) {
        this.ctx.strokeStyle = this.strokeColor;
        this.ctx.lineWidth = this.strokeWidth;
        this.ctx.lineCap = "round";
        this.ctx.lineJoin = "round";
      }
    }

    private setupCheckboxes(): void {
      this.checkboxes.forEach((checkbox) => {
        checkbox.addEventListener(
          "change",
          this.handleCheckboxChange.bind(this),
        );
      });
    }

    private setupControlButtons(): void {
      if (this.undoBtn) {
        this.undoBtn.addEventListener("click", this.undo.bind(this));
        this.updateUndoButton();
      }

      if (this.clearBtn) {
        this.clearBtn.addEventListener("click", this.clearAll.bind(this));
        this.updateClearButton();
      }
    }

    private handleCheckboxChange(event: Event): void {
      const target = event.target as HTMLInputElement;

      // Si se selecciona "Ninguno", desmarcar los otros
      if (target.value === "ninguno" && target.checked) {
        this.checkboxes.forEach((cb) => {
          if (cb.value !== "ninguno") {
            cb.checked = false;
          }
        });
      }
      // Si se selecciona otro, desmarcar "Ninguno"
      else if (target.value !== "ninguno" && target.checked) {
        this.checkboxes.forEach((cb) => {
          if (cb.value === "ninguno") {
            cb.checked = false;
          }
        });
      }

      // Disparar evento personalizado
      this.dispatchPlanosEvent();
    }

    private dispatchPlanosEvent(): void {
      const selectedPlanos = Array.from(this.checkboxes)
        .filter((cb) => cb.checked)
        .map((cb) => cb.value);

      window.dispatchEvent(
        new CustomEvent("croquis:planos-changed", {
          detail: { planos: selectedPlanos },
        }),
      );
    }

    private setupDrawingEvents(): void {
      if (!this.container) return;

      this.container.addEventListener(
        "mousedown",
        this.startDrawing.bind(this),
      );
      this.container.addEventListener("mousemove", this.draw.bind(this));
      this.container.addEventListener("mouseup", this.stopDrawing.bind(this));
      this.container.addEventListener(
        "mouseleave",
        this.stopDrawing.bind(this),
      );

      // Touch events para dispositivos móviles
      this.container.addEventListener(
        "touchstart",
        this.handleTouch.bind(this),
      );
      this.container.addEventListener("touchmove", this.handleTouch.bind(this));
      this.container.addEventListener("touchend", this.stopDrawing.bind(this));
    }

    private startDrawing(event: MouseEvent): void {
      if (this.state.readonly) return;

      this.state.isDrawing = true;
      const point = this.getMousePos(event);
      this.state.currentStroke = [point];
    }

    private draw(event: MouseEvent): void {
      if (!this.state.isDrawing || !this.ctx) return;

      const point = this.getMousePos(event);
      this.state.currentStroke.push(point);

      // Dibujar línea suave con el color azul oscuro
      this.ctx.strokeStyle = this.strokeColor;
      this.ctx.lineWidth = this.strokeWidth;
      this.ctx.beginPath();
      this.ctx.moveTo(
        this.state.currentStroke[this.state.currentStroke.length - 2].x,
        this.state.currentStroke[this.state.currentStroke.length - 2].y,
      );
      this.ctx.lineTo(point.x, point.y);
      this.ctx.stroke();
    }

    private stopDrawing(): void {
      if (this.state.isDrawing && this.state.currentStroke.length > 1) {
        // Guardar el trazo completado
        this.state.strokes.push({
          points: [...this.state.currentStroke],
          color: this.strokeColor,
          lineWidth: this.strokeWidth,
        });

        // Actualizar botones
        this.updateUndoButton();
        this.updateClearButton();

        // Disparar evento con los puntos dibujados
        window.dispatchEvent(
          new CustomEvent("croquis:drawing-complete", {
            detail: {
              points: this.state.currentStroke,
              allStrokes: this.state.strokes,
            },
          }),
        );
      }

      this.state.isDrawing = false;
      this.state.currentStroke = [];
    }

    private handleTouch(event: TouchEvent): void {
      event.preventDefault();
      const touch = event.touches[0];
      const mouseEvent = new MouseEvent(
        event.type === "touchstart"
          ? "mousedown"
          : event.type === "touchmove"
            ? "mousemove"
            : "mouseup",
        {
          clientX: touch.clientX,
          clientY: touch.clientY,
        },
      );

      if (event.type === "touchstart") this.startDrawing(mouseEvent);
      else if (event.type === "touchmove") this.draw(mouseEvent);
    }

    private getMousePos(event: MouseEvent): Point {
      if (!this.canvas) return { x: 0, y: 0 };

      const rect = this.canvas.getBoundingClientRect();
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top,
      };
    }

    private handleResize(): void {
      // Guardar los trazos actuales antes de redimensionar
      const tempStrokes = [...this.state.strokes];

      this.setupCanvas();

      // Redibujar todos los trazos
      this.redrawAll();
    }

    private redrawAll(): void {
      if (!this.ctx || !this.canvas) return;

      // Limpiar el canvas
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      // Redibujar todos los trazos guardados
      this.state.strokes.forEach((stroke) => {
        if (stroke.points.length < 2) return;

        this.ctx!.strokeStyle = stroke.color;
        this.ctx!.lineWidth = stroke.lineWidth;
        this.ctx!.beginPath();

        stroke.points.forEach((point, index) => {
          if (index === 0) {
            this.ctx!.moveTo(point.x, point.y);
          } else {
            this.ctx!.lineTo(point.x, point.y);
          }
        });

        this.ctx!.stroke();
      });
    }

    private undo(): void {
      if (this.state.strokes.length === 0) return;

      // Eliminar el último trazo
      this.state.strokes.pop();

      // Redibujar todo
      this.redrawAll();

      // Actualizar botones
      this.updateUndoButton();
      this.updateClearButton();

      // Disparar evento
      window.dispatchEvent(
        new CustomEvent("croquis:undo", {
          detail: { remainingStrokes: this.state.strokes },
        }),
      );
    }

    private clearAll(): void {
      if (this.state.strokes.length === 0) return;

      // Confirmación antes de borrar todo
      if (confirm("¿Estás seguro de que deseas borrar todo el dibujo?")) {
        this.clear();
        this.state.strokes = [];

        // Actualizar botones
        this.updateUndoButton();
        this.updateClearButton();

        // Disparar evento
        window.dispatchEvent(
          new CustomEvent("croquis:cleared", {
            detail: { cleared: true },
          }),
        );
      }
    }

    private updateUndoButton(): void {
      if (this.undoBtn) {
        this.undoBtn.disabled = this.state.strokes.length === 0;
      }
    }

    private updateClearButton(): void {
      if (this.clearBtn) {
        this.clearBtn.disabled = this.state.strokes.length === 0;
      }
    }

    // Método público para limpiar el canvas
    public clear(): void {
      if (!this.ctx || !this.canvas) return;
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    // Método para destruir los event listeners
    public destroy(): void {
      window.removeEventListener("resize", this.handleResize);
    }
  }

  // Inicializar cuando el DOM esté listo
  document.addEventListener("DOMContentLoaded", () => {
    new SketchCanvas();
  });

  // Compatibilidad con View Transitions API de Astro
  document.addEventListener("astro:page-load", () => {
    new SketchCanvas();
  });
</script>
